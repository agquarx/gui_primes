--- src/gui.rs.bak	2025-04-26 01:46:33
+++ src/gui.rs	2025-04-26 01:48:00
@@ -74,6 +74,10 @@
                 );
                 ui.label(egui::RichText::new(format!("{secs:.1} s")).font(egui::FontId::proportional(24.0)).strong());
             });
+            
+            // Safety check: if calc was running too long without progress update, reset it
+            if self.calc_running && self.started.elapsed().as_secs_f32() > 30.0 && prog >= 0.95 {
+                self.calc_running = false;
+            }
 
             ui.add_space(8.0);
             ui.horizontal(|ui| {
@@ -125,6 +129,9 @@
                         }
                         if ui.button("Stop").clicked() {
                             self.should_stop.store(true, Ordering::SeqCst);
+                            // Also set calc_running to false to reset the state
+                            self.calc_running = false;
+                            *self.prog.lock().unwrap() = 1.0; // Mark as completed
                         }
                         if ui.button("Dump").clicked() {
                             let home = env::var("HOME").unwrap_or_default();
@@ -196,6 +203,10 @@
                     for step in 0..=steps {
                         let progress = current_progress + (next_progress - current_progress) * (step as f32 / steps as f32);
                         *pr.lock().unwrap() = progress;
+                        
+                        if stop.load(Ordering::SeqCst) {
+                            *pr.lock().unwrap() = 1.0; // Ensure progress is complete when stopped
+                        }
                         ctx2.request_repaint();
                         thread::sleep(Duration::from_millis(20));
                         if stop.load(Ordering::SeqCst) {
